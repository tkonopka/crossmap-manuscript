---
title: "Diffusion enables integration of heterogeneous data and user-driven learning in a desktop knowledge-base (Figures)"
output:
  pdf_document:
    keep_tex: true
header-includes:
  \usepackage{caption}
  \usepackage{float}
  \usepackage{graphicx}
  \floatplacement{figure}{H}
  \captionsetup[figure]{labelfont={bf}, name={Figure}, labelsep=period}
---


```{r, analysis, echo=FALSE}
# load packages and settings
source("config.R")
set.seed(1292301)
# load ontology data
source("obo.R")
# gene-set analyses
go.benchmarks.size <- 1000
source("benchmarking.R")
source("copynumber.R")
# hp-mp translations
source("hpmp.R")
# exploratory searches for diseases
diseases.examples.text <-
  c("ATM",
    "skin.lesions,.arthralgia,.pulmonary.infections,.PLCG1",
    "skin.lesions,.arthralgia,.pulmonary.infection,.SYK.PIK3R1")
source("diseases.R")
```


\setcounter{figure}{1}

```{r get.exp.decomp, echo=FALSE, eval=TRUE}
# get results for one geneset, one target dataset, one action type
# (this is in Rmd because it also computes sizing for a figure using Rcss)
get.figs.info <- function(geneset.id, action="search", data=expression.results,
                         diffusion.labels=c("", "positions"),
                         dataset="positions", diffusion.value=0.2) {
  # construct contents of tables to display in figure
  result <- list()
  .ds <- dataset
  .dl1 <- diffusion.labels[1]
  .dl2 <- diffusion.labels[2]
  .data <- data[[action]][id==geneset.id & dataset==.ds]
  result[[.dl1]] <- .data[diffusion.label==.dl1]
  .temp <- .data[diffusion.label==.dl2]
  .diff.values <- .temp[[paste0("diffusion.strength.", .dl2)]]
  .temp <- .temp[.diff.values==diffusion.value]
  result[[.dl2]] <- .temp
  names(result)[names(result)==""] <- "plain"
  # compute sizing of the tables in the figures
  Rcssclass <- c("table", "expout", "genesets")
  mai <- RcssValue("par", "mai", default=rep(0.1, 4), Rcssclass=Rcssclass)
  rh <- RcssValue("table", "row.height", default=0.2, Rcssclass=Rcssclass)
  layout.heights <- mai[1]+mai[3] + (1+sapply(result, nrow))*rh
  fig.height <- sum(layout.heights)
  result$fig <- list(fig.height=fig.height, layout.heights=layout.heights)
  result
}
ehap.names <- expression.info[collection=="Haplogen"]$id
ehap.list <- setNames(ehap.names, ehap.names)
positions.decomp.figs <- lapply(ehap.list, get.figs.info,
                              action="decompose", dataset="positions")
positions.search.figs <- lapply(ehap.list, get.figs.info,
                                action="search", dataset="positions")
```


```{r boxtrends.genesets, echo=FALSE, eval=TRUE}
# helper to draw a boxtrends diagram based on benchmark performance
plot.boxtrends.genesets <- function(methods, tau, series, show.xaxis=FALSE,
                                    ylab="(total) JI",
                                    performance=benchmarks.performance, ...) {
  .tau <- tau
  perfdata <- merge(performance[tau==.tau], methods,
                   by=intersect(colnames(performance), colnames(methods)))
  perfdata <- merge(perfdata, benchmarks.summary,
                   by=intersect(colnames(perfdata), colnames(benchmarks.summary)))
  plot.boxtrends(perfdata, 
                 xy=c("method", "tauprecision"),
                 x.values=methods$method,
                 series.column=names(series)[1], series.values=series[[1]],
       	         ylab=ylab, show.xaxis=show.xaxis, ...)
}
```


```{r edata, echo=FALSE, eval=TRUE}
# objects for HAP/eHAP figure panels
ehap.geneset <- "HAP1_eHAP_symbols_z_6_fc_2_down"
edata1 <- positions.search.figs[[ehap.geneset]]
edata2 <- positions.decomp.figs[[ehap.geneset]]
edata3 <- expression.hypeR[[ehap.geneset]]
edata3 <- edata3[grep("GENCODE", label)]
edata3$log10_pval <- -log10(edata3$pval)
edata3$label <- gsub("GENCODE:", "", edata3$label)
```


```{r fig.decomposition, eval=TRUE, echo=FALSE, fig.width=4.4, fig.height=4.8, fig.cap="\\textbf{Applications of search and decomposition algorithms on gene sets.} \\label{fig:benchmarks} (A) Schematic of synthetic gene sets for benchmarking calculations. The gene pool contains all human genes (dots) and sets are based on GO annotations (color boundaries). Benchmarking datasets are generated by selecting genes from one or more sets. Three generation strategies take genes from one or more GO set (top), take subsets of genes from each GO set (middle), and augment genes from GO sets with randomly-selected genes (bottom). (B-D) Results of benchmarking calculations performed using three computational methods - the Fisher statistical test, and search and decomposition powered by nearest-neighbor algorithms. Performance is measured via the total Jaccard Index (JI), which is the sum of as many JI values as there are expected GO components in the benchmark set. (E) Visualization of differentially-expressed genes in the eHAP cell line along one of the chromosomes. (F) Output of hypeR gene-set enrichment analysis comparing DE genes with a collection of gene-sets describing genomic regions of various sizes. (G) Output from gene set search. (H) Output from gene set decomposition."}
layout(matrix(c(1, 2, 3,
                1, 4, 5,
                1, 6, 7,
                8, 8, 8,
                9, 12, 12,
                10, 12, 12,
                11, 12, 12), ncol=3, nrow=7, byrow=T),
		widths=c(2.2, 1.6, 0.6),
		heights=c(0.75, 0.75, 0.75, 0.1, 0.85, 0.88, 0.52))
#
# schematic with a genepool and benchmark types
schematic.genepool.benchmarks(xlim=c(-0.1, 2.6))
multipanelLabel(panel.labels[1])
#
# panel with effect of number of components
methods.covsig <- data.table(method=c("fisher", "search", "decomp"),
                             config.label=c("p0.05", rep("uniform_n5_diff0", 2)),
                             coverage=0.5, signal=0.5)
plot.boxtrends.genesets(methods.covsig, 0, 
                        series=list(components=c(1,2,3,4)),
	                    main="cov=0.5, signal=0.5")
multipanelLabel(panel.labels[2])		    
plot.boxtrends.legend(c(-0.55, 1.1), "Components", 1:4)
#
# panel with effect of coverage
methods.compsig <- data.table(method=c("fisher", "search", "decomp"),
                              config.label=c("p0.05", rep("uniform_n5_diff0", 2)),
			                  components=3, signal=0.5)
plot.boxtrends.genesets(methods.compsig, 0, 
                        series=list(coverage=seq(0.25, 1, by=0.25)),
                        main="comp=3, signal=0.5",
		    ylim=c(0, 4))
multipanelLabel(panel.labels[3])
plot.boxtrends.legend(c(-0.55, 1.1), "Coverage", seq(0.25, 1, by=0.25))	     
#
# panel with effect of signal-to-noise percentage
methods.covcomp <- data.table(method=c("fisher", "search", "decomp"),
                              config.label=c("p0.05", rep("uniform_n5_diff0", 2)),
                              coverage=0.5, components=3)
plot.boxtrends.genesets(methods.covcomp, 0,
                    series=list(signal=seq(0.25, 1, by=0.25)),
                    main="comp=3, cov=0.5",
		    ylim=c(0, 4), show.xaxis=TRUE)
multipanelLabel(panel.labels[4])
plot.boxtrends.legend(c(-0.55, 1.1), "Signal", seq(0.25, 1, by=0.25))
#
# a bit of empty space
par(mai=rep(0.01, 4)); plot.new()
#
# chromosome 15
ehap.chr15 <- function() {
  ehap.DE.15 <- ehap.DE.table[chr=="15" & highTPM>1]
  fc <- log10(2)
  ehap.DE.15$DE.up <- ehap.DE.15$log10.fc > fc & ehap.DE.15$z > 6
  ehap.DE.15$DE.down <- ehap.DE.15$log10.fc < (-fc) & ehap.DE.15$z < (-6)
  plot.chromosome(ehap.DE.15[highTPM>1],
                  xy=c("position", "log10.fc"),
                  main="Differential expression (eHAP / HAP1)",
                  xlab="chr15 position (M)",
                  ylab="fold change", ylim=log10(6)*c(-1, 1),
                  genes.up=ehap.DE.15[DE.up==TRUE]$gene_symbol,
                  genes.down=ehap.DE.15[DE.down==TRUE]$gene_symbol,
                  legend.pos=c(-7e6, log10(12)))
}
ehap.chr15()
multipanelLabel(panel.labels[5])
#
# results of search and decomposition on the eHAP dataset
plot.outputs.barplot(edata1$plain,
                     label.col="target_name", value.col="distance",
                     xlab="Search (distance)", xlim=c(0, 1),
                     Rcssclass="ehap")
multipanelLabel(panel.labels[7])
plot.outputs.barplot(edata2$plain,
                     label.col="target_name", value.col="coefficient",
                     xlab="Decomposition (coefficient)",
                     Rcssclass=c("ehap", "decomp"))
multipanelLabel(panel.labels[8])
#
# results from an alternative tool
plot.outputs.barplot(head(edata3, 18),
                     label.col="label", value.col="log10_pval",
                     xlab="Enrichment (-log10 pvalue)",
                     Rcssclass=c("ehap", "enrichment"))
text(38, -17, paste0(nrow(edata3), " sets\nat p<0.05"),
     cex=0.85, col="#000000", adj=c(0, 0))
multipanelLabel(panel.labels[6])
```




```{r plot.helpers, eval=TRUE, echo=FALSE}
# draw an arrow to the first bar in a histogram
top.arrow <- function(histcounts, i=1, x=3.5) {
  if (length(i)>1) {
    for (.i in i) {
      top.arrow(histcounts, .i, x=x)
    }
  } else {
    top.count <- histcounts[i]
    top.perc <- round(100 * top.count / sum(histcounts))
    if (i==1) {
      text(x, top.count*0.8, paste0(top.perc,"%"), Rcssclass=c("hist", "label"))
      arrows(x-0.15, top.count*0.8, 0.65, top.count*0.8, Rcssclass="hist")
    } else if (i==2) {
      text(x, top.count*1.4, paste0(top.perc, "%"), Rcssclass=c("hist", "label"))
      arrows(x-0.15, top.count*1.4, 1.65, top.count*1.01, Rcssclass="hist")
    } else if (i==3) {
      text(x, top.count*1.4, paste0(top.perc, "%"), Rcssclass=c("hist", "label"))
      arrows(x-0.15, top.count*1.4, 2.65, top.count*1.01, Rcssclass="hist")
    }
  }
}
hist.mean <- function(hist.data, y=max(hist.data$counts), adj=c(0, 0)) {
  .mean <- mean(rep(hist.data$mid, hist.data$counts))
  lines(rep(.mean-0.5, 2), c(0, y), Rcssclass=c("hist", "mean"))
  text(.mean-0.5, y, paste0("mean: ", signif(.mean, 3)), adj=adj,
       Rcssclass=c("hist", "mean"))
}
```



```{r fig.translation, eval=TRUE, echo=FALSE, fig.width=6.4, fig.height=2.3, fig.cap="\\textbf{Ontology translation.} (A) Examples of translations between human and mammalian phenotype ontology terms. Queries are from the HP ontology; expected outputs are MP terms suggested by an ontology-aware translation algorithm; empirical outputs are from nearest-neighbor searches. Note that while HP and MP terms are summarized by their name only, calculations rely on full term definitions. (B) Summary of translation precision compared with the expected mapping. Bars represent means over all HP terms, whiskers represent 25%-75% quantile ranges. (C) Summary of translation performance in terms of the ontology-graph distance between expected and output terms. (D) Distribution of path length errors. (E) Examples of annotations added through a graphical-user interface. (F) Impact of manual training items on the translation of all HP terms. (G) Impact of user-driven learning (UDL) on the HP terms that were targeted for training."}
layout(matrix(c(1,1,1,5,5,6,
                1,1,1,7,8,8,
                2,3,4,7,8,8,
		2,3,4,7,9,9),
		ncol=6, nrow=4, byrow=T),
       widths=c(0.8, 0.8, 2.2, 0.7, 0.6, 1.3), height=c(0.7, 0.4, 0.4, 0.8))
#
# panel with examples of translation
show.examples <- c("HP:0000024", "HP:0002330", "HP:0000616")
show.df <- hpmp.viz[id %in% show.examples & viz=="plain"]
show.df$target_name <- gsub("abnormal", "abn.", show.df$target_name)
show.df$target_name <- gsub("system", "sys.", show.df$target_name)
plot.table.expout(show.df, widths=c(0.75, 0.85, 0.85, 0.2),
                  show.columns=c("query", "expected", "output"),
		  Rcssclass="expout")
multipanelLabel(panel.labels[1])
#
# panels with classical performance metrics
hpmp.one <- hpmp.viz[viz=="plain"]
plot.perfbars2(hpmp.one, value.cols=c("precision", "precision_bestN"),
               labels=c("best of 1", "best of 5"),
               ylim=c(0, 1), axis.y=-0.075,
               main="Precision", Rcssclass=c("plain", "left"))
multipanelLabel(panel.labels[2])
plot.perfbars2(hpmp.one, value.cols=c("pathlen", "pathlen_bestN"),
               labels=c("best of 1", "best of 5"),
               ylim=c(0, 5), axis.y=-0.075,
               main="Path length", Rcssclass=c("plain", "right"))
multipanelLabel(panel.labels[3])
#
# panel with alternative assessment - distributions of path lengths
plain.hist <- plot.hist(hpmp.viz[viz=="plain"]$pathlen_bestN,
                        xlab="Path length, best of 5", ylab="",
		      xlim=c(-0.2, 10),
                      main="Path length distribution")
top.arrow(plain.hist$counts, i=1:3)
multipanelLabel(panel.labels[4], x=-2.5)
#
# two panels with examples of manual training
schematic.manual.learning("sleepy langour", "", widths=c(0.4, 0.6),
                          main="Manual training items", Rcssclass="left")
multipanelLabel(panel.labels[5])
schematic.manual.learning("disabling", "heightened", widths=c(0.4, 0.6),
                          Rcssclass="right")
#
# proportion of items that change
duo <- hpmp.viz[viz %in% c("diffused", "best")]
duo$duo <- "-"
duo$duo[duo$viz=="best"] <- "+"
duo.changed <- duo[, list(top=length(unique(target))>1,
                          top_N=length(unique(target_N))>1), by="id"]
duo.summary <- data.table(changed=c("changed", "unchanged"),
                          count=c(sum(duo.changed$top), sum(!duo.changed$top)),
                          count_N=c(sum(duo.changed$top_N), sum(!duo.changed$top_N)))
plot.stackedbars(duo.summary,
                 value.col=c("count", "count_N"),
                 factor.col="changed", value.template="PERCENT%",
                 labels=c("top 1", "top 5"),
                 ylab="HP terms", main="",
                 legend.pos=c(-0.5, -3500),
		 Rcssclass="manual")
rm(duo, duo.changed, duo.summary)
multipanelLabel(panel.labels[6])
#
# panels with histograms before and after diffusion
show.ids <- hpmp.manual.attempted.ids
before.after <- hpmp.viz[viz %in% c("diffused", "best") & id %in% show.ids]
fwrite(before.after, file=file.path(results.dir, "hpmp.UDL.tsv"), sep="\t")
before.after <- dcast(before.after, id ~ viz, value.var="pathlen_bestN")
before.after <- before.after[diffused>=8]
before.after.main <- paste0(nrow(before.after), " selected queries")
before.hist <- plot.hist(before.after$diffused,
                         breaks=seq(-0.5, 16.5),
			             xlim=c(-0.2, 14), ylim=c(0, 95),
			             xlab="", main=before.after.main, Rcssclass="top")
hist.mean(before.hist, max(before.hist$counts)*0.8, adj=c(-0.06, 1))
text(1, 80, "before UDL", Rcssclass=c("hist", "manual"))
multipanelLabel(panel.labels[7], x=-3)
after.hist <- plot.hist(before.after$best,
                        breaks=seq(-0.5, 16.5),
                        xlim=c(-0.2, 14), ylim=c(0, 95),
                        xlab="Path length, best of 5",
                        main="", Rcssclass="bottom")
hist.mean(after.hist, max(before.hist$counts)*0.8, adj=c(-0.06, 1))
text(1, 80, "after UDL", Rcssclass=c("hist", "manual"))
rm(show.ids, before.after.main, before.hist, after.hist)
```



```{r fig.diseases, eval=TRUE, echo=FALSE, fig.width=6.4, fig.height=2.1, fig.cap="\\textbf{Examples of queries against a disease knowledge-base.} \\label{fig:diseases} (A) Results from a single-gene query with two diffusion settings. Hits are presented in ranked order. (B) Results from a multi-modal query with multiple phenotypes and genes."}
layout(matrix(c(1, 2), ncol=2, nrow=1, byrow=T),
       widths=c(1, 1))
#
# diseases searches for single gene
example1 <- diseases.results[id=="ATM"]
example1 <- example1[order(rank)]
setnames(example1, c("id", "target", "target_name"), c("query", "id", "name"))
plot.examples(queries=c("\"ATM\""),
              diffusion=c("-", "pathways"),
	          hits = list(example1[grep("diff0,0$", config.label)],
	                      example1[grep("diff1,0$", config.label)]),
              num.hits=8)
multipanelLabel(panel.labels[1])
#
# diseases searches with many phenotypes
example2 <- diseases.results[grepl("SYK", id) &
                             grepl("diff1,1$", config.label)]
example2 <- example2[order(rank)]
setnames(example2, c("id", "target", "target_name"), c("query", "id", "name"))
example2.query <- example2$query[1]
plot.examples(queries=paste0("\"", gsub("\\.", " ", example2.query), "\""),
              diffusion="pathways, interactions",
	          hits = list(example2), num.hits=8,
	          colwidths=c(0.12, 0.89, 0))
multipanelLabel(panel.labels[2])
```

